---
description: "Run pre-PR tests, create pull request with template, and setup CI pipeline"
---

# üîÑ Create Pull Request

**Context Files**: Please read .github/pull_request_template.md, pyproject.toml, CLAUDE.md, and .github/workflows/ first.

Execute pre-PR validation, create structured pull request, and ensure CI pipeline readiness.

## üìù PR Context

**Additional Details:** $ARGUMENTS

---

## üß™ Pre-PR Validation Pipeline

### **Step 1: Code Quality Checks**

#### **Linting & Formatting**

```bash
# Ruff formatting check
echo "üé® Checking code formatting..."
uv run ruff format --check . || {
    echo "‚ùå Code formatting issues found. Run: uv run ruff format ."
    exit 1
}

# Ruff linting check
echo "üîç Running linting checks..."
uv run ruff check . || {
    echo "‚ùå Linting issues found. Run: uv run ruff check --fix ."
    exit 1
}

# Type checking with mypy
echo "üîç Running type checks..."
uv run mypy src/ || {
    echo "‚ùå Type checking failed. Fix type errors before creating PR."
    exit 1
}

# Check for debug statements and breakpoints
echo "üîç Checking for debug code..."
grep -r "pdb\.set_trace\|breakpoint()\|print(" src/ && {
    echo "‚ùå Debug statements found. Remove before creating PR."
    exit 1
} || echo "‚úÖ No debug statements found"
```

#### **Security & Dependencies**

```bash
# Check UV project sync status
echo "üì¶ Checking dependency synchronization..."
uv sync --dry-run || {
    echo "‚ùå Dependencies out of sync. Run: uv sync"
    exit 1
}

# Security check for sensitive data in changes
echo "üîê Checking for sensitive data..."
git diff main --name-only | xargs grep -l "password\|secret\|key\|token\|api.*key" 2>/dev/null && {
    echo "‚ùå Potential sensitive data found in changes. Review carefully."
    exit 1
} || echo "‚úÖ No sensitive data detected"

# Check for hardcoded secrets in new code
git diff main | grep -E "\+.*['\"].*[a-zA-Z0-9]{20,}['\"]" && {
    echo "‚ö†Ô∏è  Potential hardcoded secrets detected. Please review."
} || echo "‚úÖ No hardcoded secrets detected"
```

### **Step 2: Test Execution**

#### **Unit Tests**

```bash
# Run pytest with coverage
echo "üß™ Running unit tests..."
if [ -d "tests/" ] || [ -d "test/" ]; then
    uv run pytest -v --cov=src --cov-report=term-missing --cov-fail-under=80 || {
        echo "‚ùå Tests failed or coverage below 80%. Fix tests before creating PR."
        exit 1
    }
    echo "‚úÖ All tests passed with sufficient coverage"
else
    echo "‚ö†Ô∏è  No test directory found. Consider adding tests."
fi
```

#### **Integration Tests**

```bash
# Run integration tests if they exist
echo "üîó Running integration tests..."
if [ -d "tests/integration/" ]; then
    uv run pytest tests/integration/ -v || {
        echo "‚ùå Integration tests failed. Fix before creating PR."
        exit 1
    }
    echo "‚úÖ Integration tests passed"
else
    echo "‚ÑπÔ∏è  No integration tests found"
fi

# Check if any test configuration files need updates
if [ -f "pytest.ini" ] || [ -f "pyproject.toml" ]; then
    echo "‚úÖ Test configuration files present"
fi
```

#### **Build Verification**

```bash
# Verify project can be installed in development mode
echo "üî® Verifying project installation..."
uv sync || {
    echo "‚ùå Project installation failed. Check pyproject.toml"
    exit 1
}

# Check if project has entry points or scripts
if grep -q "scripts\|entry-points" pyproject.toml 2>/dev/null; then
    echo "‚úÖ Project scripts/entry-points configured"
fi

# Docker build test (if Dockerfile exists)
if [ -f "Dockerfile" ]; then
    echo "üê≥ Testing Docker build..."
    docker build -t test-build . || {
        echo "‚ùå Docker build failed"
        exit 1
    }
    echo "‚úÖ Docker build successful"
fi
```

### **Step 3: Branch Synchronization**

#### **Rebase with Main**

```bash
# Fetch latest changes
git fetch origin main

# Check if rebase is needed
git merge-base --is-ancestor main HEAD || {
    echo "Rebase required - main has new commits"
    git rebase origin/main
}

# Verify clean state after rebase
git status --porcelain
```

## üìã Pull Request Creation

### **Branch Analysis**

Extract information for PR template:

#### **Change Summary**

- **Branch Type**: [feature/fix/docs/refactor]
- **Scope**: [Affected components/modules]
- **Files Changed**: [Count and primary locations]
- **Complexity**: [Simple/Medium/Complex based on changes]

#### **Commit Analysis**

```bash
# Get commit messages for PR description
git log main..HEAD --oneline
git log main..HEAD --pretty=format:"- %s"

# Analyze change patterns
git diff main --stat
git diff main --shortstat
```

### **PR Template Population**

#### **Standard Template Structure**

````markdown
## üìã Change Summary

### What Changed

- [Bullet points describing key changes]

### Why Changed

- [Business/technical justification]

### How It Works

- [Brief technical explanation]

## üß™ Testing

### Test Coverage

- [ ] Unit tests added/updated
- [ ] Integration tests verified
- [ ] Manual testing completed

### Test Commands

```bash
# Commands to verify the changes
uv run pytest -v --cov=src
uv run ruff check . && uv run ruff format --check .
uv run mypy src/
```
````

## üîç Review Checklist

### Code Quality

- [ ] Code follows project standards
- [ ] No hardcoded values or secrets
- [ ] Error handling is appropriate
- [ ] Performance considerations addressed

### Documentation

- [ ] README updated if needed
- [ ] API documentation current
- [ ] Inline comments for complex logic
- [ ] CHANGELOG entry added

### Security & Performance

- [ ] No security vulnerabilities introduced
- [ ] Performance impact assessed
- [ ] Database migrations tested
- [ ] Breaking changes documented

## üöÄ Deployment Notes

### Environment Impact

- [ ] Development environment tested
- [ ] Staging deployment plan ready
- [ ] Production considerations documented

### Migration Requirements

- [ ] Database changes documented
- [ ] Configuration updates needed
- [ ] Dependency updates required

---

Closes #[issue-number]

````

### **PR Creation Command**

#### **Step 1: Remote Branch Status Check**

```bash
echo "üîç Checking remote branch status..."

CURRENT_BRANCH=$(git branch --show-current)
echo "üìç Current branch: $CURRENT_BRANCH"

# Check if remote branch exists
REMOTE_EXISTS=$(git ls-remote --heads origin $CURRENT_BRANCH)

if [ -z "$REMOTE_EXISTS" ]; then
    echo "üÜï Remote branch doesn't exist - will create and push"
    NEED_PUSH=true
    COMMITS_AHEAD=0
else
    echo "‚úÖ Remote branch exists - checking sync status"

    # Fetch latest to ensure accurate comparison
    git fetch origin $CURRENT_BRANCH

    # Check ahead/behind status
    AHEAD_BEHIND=$(git rev-list --left-right --count origin/$CURRENT_BRANCH...$CURRENT_BRANCH 2>/dev/null || echo "0	0")
    COMMITS_BEHIND=$(echo $AHEAD_BEHIND | cut -f1)
    COMMITS_AHEAD=$(echo $AHEAD_BEHIND | cut -f2)

    echo "üìä Branch status:"
    echo "   üìà Commits ahead of remote: $COMMITS_AHEAD"
    echo "   üìâ Commits behind remote: $COMMITS_BEHIND"

    if [ $COMMITS_AHEAD -gt 0 ]; then
        echo "‚ö†Ô∏è  Local branch has unpushed commits"
        NEED_PUSH=true
    else
        echo "‚úÖ Local branch is up-to-date with remote"
        NEED_PUSH=false
    fi

    if [ $COMMITS_BEHIND -gt 0 ]; then
        echo "‚ö†Ô∏è  Warning: Remote branch has newer commits!"
        echo "üîÑ Consider running 'sync-with-main' command first"
        read -p "Continue anyway? (y/N): " continue_choice
        if [[ ! $continue_choice =~ ^[Yy]$ ]]; then
            echo "‚ùå PR creation cancelled. Please sync first."
            exit 1
        fi
    fi
fi

echo ""
```

#### **Step 2: Push if Needed**

```bash
if [ "$NEED_PUSH" = true ]; then
    echo "üì§ Pushing local commits to remote..."

    if [ -z "$REMOTE_EXISTS" ]; then
        # First push - set upstream tracking
        echo "üÜï Creating and setting upstream branch..."
        git push -u origin $CURRENT_BRANCH
    else
        # Regular push
        git push origin $CURRENT_BRANCH
    fi

    # Check push success
    if [ $? -eq 0 ]; then
        echo "‚úÖ Successfully pushed $COMMITS_AHEAD commit(s) to origin/$CURRENT_BRANCH"
    else
        echo "‚ùå Push failed! Cannot create PR without remote branch."
        echo "üîß Possible issues:"
        echo "   - Network connection problem"
        echo "   - Remote branch conflicts"
        echo "   - Permission issues"
        exit 1
    fi
else
    echo "‚úÖ Remote branch is already up-to-date - skipping push"
fi

echo ""
```

#### **Step 3: Create Pull Request**

```bash
echo "üîÑ Creating Pull Request..."

# Check if GitHub CLI is available
if ! command -v gh &> /dev/null; then
    echo "‚ö†Ô∏è  GitHub CLI not found. Creating PR manually:"
    echo "üîó Open this URL: https://github.com/SilasPignotti/urbanIQ/compare/main...$CURRENT_BRANCH"
    echo "üìã Use the PR template from .github/pull_request_template.md"
    exit 0
fi

# Check if user is authenticated
if ! gh auth status &> /dev/null; then
    echo "‚ö†Ô∏è  GitHub CLI not authenticated. Creating PR manually:"
    echo "üîó Open this URL: https://github.com/SilasPignotti/urbanIQ/compare/main...$CURRENT_BRANCH"
    echo "üí° To setup GitHub CLI: gh auth login"
    exit 0
fi

# Generate PR title from recent commits
RECENT_COMMITS=$(git log --oneline main..$CURRENT_BRANCH --reverse | head -5)
COMMIT_COUNT=$(echo "$RECENT_COMMITS" | wc -l | tr -d ' ')

if [ $COMMIT_COUNT -eq 1 ]; then
    # Single commit - use its message as title
    PR_TITLE=$(echo "$RECENT_COMMITS" | cut -d' ' -f2-)
else
    # Multiple commits - create descriptive title
    BRANCH_TYPE=$(echo $CURRENT_BRANCH | cut -d'/' -f1)
    BRANCH_NAME=$(echo $CURRENT_BRANCH | cut -d'/' -f2- | sed 's/-/ /g')
    PR_TITLE="$BRANCH_TYPE: $BRANCH_NAME"
fi

echo "üìù PR Title: $PR_TITLE"
echo "üìä Commits in PR: $COMMIT_COUNT"
echo ""

# Create PR using GitHub CLI
echo "üöÄ Creating Pull Request..."
gh pr create \
  --title "$PR_TITLE" \
  --body "$(cat .github/pull_request_template.md 2>/dev/null || echo 'Automated PR creation - please fill in details')" \
  --base main \
  --head $CURRENT_BRANCH \
  --assignee @me

if [ $? -eq 0 ]; then
    echo "‚úÖ Pull Request created successfully!"
    echo ""

    # Show PR details
    PR_URL=$(gh pr view $CURRENT_BRANCH --json url --jq '.url')
    echo "üîó PR URL: $PR_URL"
    echo "üìã Next steps:"
    echo "   1. Review and update PR description if needed"
    echo "   2. Wait for CI/CD checks to complete"
    echo "   3. Request reviews if needed"
    echo "   4. Merge when ready"

    # Optionally open PR in browser
    read -p "üìñ Open PR in browser? (y/N): " open_choice
    if [[ $open_choice =~ ^[Yy]$ ]]; then
        gh pr view $CURRENT_BRANCH --web
    fi
else
    echo "‚ùå Failed to create PR with GitHub CLI"
    echo "üîó Manual creation URL: https://github.com/SilasPignotti/urbanIQ/compare/main...$CURRENT_BRANCH"
fi
````

## üîÑ CI/CD Pipeline Setup

### **Workflow Verification**

#### **GitHub Actions Status**

```bash
# Check if workflow files exist
ls -la .github/workflows/

# Validate workflow syntax
gh workflow list
gh workflow view [workflow-name]
```

#### **Pipeline Jobs Expected**

- **Code Quality**: Ruff linting & formatting, mypy type checking
- **Testing**: pytest unit tests with coverage reporting
- **Build**: UV sync and project installation verification
- **Security**: Dependency vulnerability scanning

### **Status Check Requirements**

Configure branch protection rules:

```yaml
required_status_checks:
  strict: true
  contexts:
    - "ci/ruff-lint"
    - "ci/ruff-format"
    - "ci/mypy"
    - "ci/pytest"
    - "ci/uv-sync"
```

## üìä PR Quality Report

### **Validation Results**

- **Ruff Linting**: [‚úÖ Pass / ‚ùå Fail with details]
- **Ruff Formatting**: [‚úÖ Pass / ‚ùå Needs formatting]
- **Type Checking**: [‚úÖ Pass / ‚ùå Type errors found]
- **Tests**: [Coverage percentage and pass/fail status]
- **UV Sync**: [‚úÖ Dependencies in sync / ‚ùå Sync required]

### **Change Metrics**

- **Files Modified**: [Count and breakdown by type]
- **Lines Added/Removed**: [Net change statistics]
- **Test Coverage**: [Before/after coverage comparison]
- **Complexity Score**: [Simple/Medium/Complex assessment]

### **Review Readiness**

- **Documentation**: [Complete/needs update]
- **Testing**: [Comprehensive/adequate/needs work]
- **Dependencies**: [None/minor/major updates]
- **Breaking Changes**: [None/documented/requires migration]

## üéØ Post-PR Actions

### **Immediate Next Steps**

1. **Monitor CI Pipeline**: Watch for any failures
2. **Address Feedback**: Respond to review comments promptly
3. **Update Documentation**: Based on review feedback
4. **Prepare for Merge**: Ensure all checks pass

### **Merge Strategy**

Based on branch type and changes:

- **Feature Branches**: Squash and merge (clean history)
- **Hotfixes**: Merge commit (preserve urgency context)
- **Documentation**: Squash and merge (simplified history)

### **Post-Merge Cleanup**

```bash
# After successful merge
git checkout main
git pull origin main
git branch -d feature/branch-name  # Delete local branch
git push origin --delete feature/branch-name  # Delete remote branch
```

---

## ‚ö†Ô∏è Common Issues & Solutions

### **Pre-PR Failures**

- **Test Failures**: Run `uv run pytest -v` and fix failing tests
- **Ruff Issues**: Run `uv run ruff check --fix .` and `uv run ruff format .`
- **Type Errors**: Run `uv run mypy src/` and fix type issues
- **Merge Conflicts**: Rebase with main using `git rebase origin/main`
- **Dependency Issues**: Run `uv sync` to resolve dependency problems

### **CI Pipeline Issues**

- **Flaky Tests**: Re-run with `uv run pytest --lf` (last failed) or investigate root cause
- **UV Sync Failures**: Check pyproject.toml syntax and dependency compatibility
- **Timeout Issues**: Optimize test execution or increase CI timeout limits
- **mypy Cache Issues**: Clear cache with `uv run mypy --clear-cache`

Ready to create professional pull requests with comprehensive validation! üöÄ
